#!/usr/bin/env python3

from pathlib import Path
from typing import List, TextIO
import subprocess

import sys
sys.path.append(str(Path(__file__).resolve().parents[1]))
from python_utilities.paths import ProjectPaths
from python_utilities.format import AnsiFormat
from python_utilities.git import Git

class Hook:
    """
    A wrapper around tool scripts to execute
    """

    def __init__(self, script: Path, arguments: List[str] = None, message=None):
        """
        Constructs this hook from the given arguments

        :param Path script: the script to execute
        :param List[str] Arguments: the list of arguments to add to the script
        :param str message: the message to print while validating
        """
        self._script = script
        self._command = [str(self._script)]
        if arguments is not None:
            self._command.extend(arguments)
        self._message = message or str(self._script.name)

    def execute(self) -> subprocess.CompletedProcess:
        """
        Executes this script and returns the completed process

        :return CompletedProcess: the completed process
        """
        return subprocess.run(self._command, capture_output=True)

    @property
    def message(self):
        """
        Gets the message to print
        """
        return self._message


class HookReporter:
    """
    A class for generating a report by running a sequence of scripts for
    pre-commit hook validation

    All scripts are relative to the specified hook-root, which by default is
    the tools directory
    """

    def __init__(self, hook_root: Path = None):
        """
        Constructs this HookReporter

        :param Path hook_root: the main root for tool scripts to exist in
        """
        self._hooks: List[Hook] = []
        self._hook_root: Path = hook_root or ProjectPaths.tools_root

    def add_hook(self, hook: Hook):
        """
        Adds a hook manually

        :param Hook hook: the hook to add
        """
        self._hooks.append(hook)

    def emplace_hook(self,
                     script_name: str,
                     arguments: List[str] = None,
                     message: str = None):
        """
        Constructs and adds a hook with the specified script_name. The script
        is relative to the hook root

        :param str script_name: the script which must be relative to the root
        :param List[str] arguments: additional arguments to forward
        :param str message: the message to output during validation
        """
        script_path = Path(self._hook_root / script_name).resolve()

        self.add_hook(Hook(script_path, arguments=arguments, message=message))

    def report(self,
               stdout: TextIO = sys.stdout,
               column_width: int = 80) -> int:
        """
        Generates a report by running each of the scripts in sequence.

        A report is considered failed if any one of the hooks fails. A failure
        from a hook does not stop subsequent checks from occurring.

        :param TextIO stdout: the output console to write to
        :param int column_width: the number of columns across to use for
                                 formatting
        :return int: 0 on success, 1 on any hook failure
        """

        stdout = stdout or sys.stdout

        count = 0
        is_passing = True
        for hook in self._hooks:
            count +=1

            process = hook.execute()

            prefix = f"{count}."

            if process.returncode == 0:
                lines: bytes = process.stdout
                color = AnsiFormat.GREEN
                state = "Passed"
            else:
                lines: bytes = process.stderr
                color = AnsiFormat.RED
                state = "Failed"

            message = hook.message

            message_start = f"{prefix: <4}{message}"
            message_end = state
            padding_length = column_width - len(message_end)

            print(
                f"{color}{message_start:.<{padding_length}}"
                f"{message_end}{AnsiFormat.RESET}",
                file=stdout
            )
            lines = lines.decode('utf-8').strip()
            if lines:
                for line in lines.split('\n'):
                    print(
                        f"    {color}|{AnsiFormat.RESET} {line}",
                        file=stdout
                    )

            is_passing = is_passing and (process.returncode == 0)

        return 0 if is_passing else 1

def main():

    git = Git()

    modified = git.changed_files()
    staged = git.changed_files(cached=True)

    overlap = set(modified).intersection(staged)

    if len(overlap) > 0:
        print(
            f"{AnsiFormat.YELLOW}CAUTION: The following staged files have "
            f"untracked modifications: {AnsiFormat.RESET}",
            file=sys.stderr
        )
        for file in overlap:
            print(
                f"{AnsiFormat.YELLOW} â€¢ {file}{AnsiFormat.RESET}",
                file=sys.stderr
            )
        print(
            f"{AnsiFormat.YELLOW}This can be ignored if this was intentional."
            f"{AnsiFormat.RESET}",
            file=sys.stderr
        )
        print(file=sys.stderr)


    reporter = HookReporter()

    reporter.emplace_hook(
        script_name="check-python-codestyle.py",
        message="Checking python codestyle",
        arguments=["--source-group=staged", "--no-progress"]
    )
    reporter.emplace_hook(
        script_name="check-cpp-codestyle.py",
        message="Checking C++ codestyle",
        arguments=["--source-group=staged", "--no-progress"]
    )
    reporter.emplace_hook(
        script_name="check-cpp-clang-tidy.py",
        message="Checking C++ clang-tidy",
        arguments=["--source-group=staged", "--no-progress"]
    )
    reporter.emplace_hook(
        script_name="check-license-copyright.py",
        message="Checking license copyrights",
        arguments=["--source-group=staged", "--no-progress"]
    )
    reporter.emplace_hook(
        script_name="check-trailing-newline.py",
        message="Checking trailing newline",
        arguments=["--source-group=staged", "--no-progress"]
    )
    reporter.emplace_hook(
        script_name="check-whitespace.py",
        message="Checking whitespace",
        arguments=["--source-group=staged", "--no-progress"]
    )

    return reporter.report()


if __name__ == "__main__":
    import sys
    sys.exit(main())
